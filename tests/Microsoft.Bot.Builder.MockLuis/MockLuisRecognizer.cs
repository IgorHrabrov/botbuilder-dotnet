// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

using System;
using System.Diagnostics;
using System.IO;
using System.Net.Http;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Bot.Builder.AI.Luis;
using Microsoft.Bot.Builder.Dialogs.Debugging;
using Microsoft.Bot.Configuration;
using Newtonsoft.Json;
using RichardSzalay.MockHttp;

namespace Microsoft.Bot.Builder.MockLuis
{
    /// <summary>
    /// Test class for creating cached LUIS responses for testing.
    /// </summary>
    /// <remarks>
    /// This will either use a cached LUIS response or generate a new one by calling LUIS.
    /// </remarks>
    public class MockLuisRecognizer : IRecognizer
    {
        private LuisApplication _application;
        private string _responseDir;
        private LuisPredictionOptions _options;
        private string _name;

        /// <summary>
        /// Initializes a new instance of the <see cref="MockLuisRecognizer"/> class.
        /// </summary>
        /// <param name="application">LUIS application information.</param>
        /// <param name="resourceDir">Where the settings file generated by lubuild is found.</param>
        /// <param name="options">LUIS options.</param>
        public MockLuisRecognizer(
            LuisApplication application,
            string resourceDir,
            LuisPredictionOptions options = null)
        {
            _application = application;
            _responseDir = Path.Combine(resourceDir, "cachedResponses");
            _options = options;
            if (!Directory.Exists(_responseDir))
            {
                Directory.CreateDirectory(_responseDir);
            }

            var region = new Uri(application.Endpoint).Host;
            region = region.Substring(0, region.IndexOf('.'));
            _name = $"_{application.ApplicationId}_{region}.json";
        }

        public async Task<RecognizerResult> RecognizeAsync(ITurnContext context, CancellationToken cancellationToken)
            => await InternalRecognize<RecognizerResult>(context, cancellationToken).ConfigureAwait(false);

        public async Task<T> RecognizeAsync<T>(ITurnContext context, CancellationToken cancellationToken)
            where T : IRecognizerConvert, new()
         => await InternalRecognize<T>(context, cancellationToken).ConfigureAwait(false);

        private async Task<T> InternalRecognize<T>(ITurnContext context, CancellationToken cancellationToken)
          where T : IRecognizerConvert, new()
        {
            var utterance = context.Activity?.AsMessageActivity()?.Text;
            var client = GetMockedClient(utterance);
            var recognizer = new LuisRecognizer(_application, _options, true, client);
            var result = await recognizer.RecognizeAsync(context, cancellationToken);
            if (client == null)
            {
                // Save response
                var outPath = ResponsePath(utterance);
                File.WriteAllText(outPath, JsonConvert.SerializeObject(result.Properties["luisResult"]));
            }

            var finalResult = new T();
            finalResult.Convert(result);
            return finalResult;
        }

        private string ResponsePath(string utterance)
            => Path.Combine(_responseDir, $"{utterance.StableHash()}{_name}");

        private HttpClientHandler GetMockedClient(string utterance)
        {
            HttpClientHandler client = null;
            if (utterance != null)
            {
                var response = ResponsePath(utterance);
                if (File.Exists(response))
                {
                    var handler = new MockHttpMessageHandler();
                    handler
                        .When(_application.Endpoint + "*")
                        .WithPartialContent(utterance)
                        .Respond("application/json", File.OpenRead(response));
                    client = new MockedHttpClientHandler(handler.ToHttpClient());
                }
            }

            return client;
        }
    }
}
